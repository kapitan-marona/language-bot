# components/translator.py
from __future__ import annotations

import asyncio
import logging
from typing import Literal, Dict, Any
from telegram import InlineKeyboardButton, InlineKeyboardMarkup

from components.gpt_client import ask_gpt  # <‚Äî –Ω—É–∂–µ–Ω –¥–ª—è do_translate

logger = logging.getLogger(__name__)

Direction = Literal["ui‚Üítarget", "target‚Üíui"]
Output = Literal["text", "voice"]
TStyle = Literal["casual", "business"]

# –§–ª–∞–∂–∫–∏ –∏ –∫–æ—Ä–æ—Ç–∫–∏–µ —è—Ä–ª—ã–∫–∏ —è–∑—ã–∫–æ–≤
FLAGS = {"ru":"üá∑üá∫","en":"üá¨üáß","fr":"üá´üá∑","es":"üá™üá∏","de":"üá©üá™","sv":"üá∏üá™","fi":"üá´üáÆ"}
SHORT = {"ru":"RU","en":"EN","fr":"FR","es":"ES","de":"DE","sv":"SV","fi":"FI"}

LANG_TITLES = {
    "ru": "üá∑üá∫ –†—É—Å—Å–∫–∏–π",
    "en": "üá¨üáß English",
    "fr": "üá´üá∑ Fran√ßais",
    "es": "üá™üá∏ Espa√±ol",
    "de": "üá©üá™ Deutsch",
    "sv": "üá∏üá™ Svenska",
    "fi": "üá´üáÆ Suomi",
}

# –ß–µ–ª–æ–≤–µ–∫–æ—á–∏—Ç–∞–µ–º—ã–µ –Ω–∞–∑–≤–∞–Ω–∏—è (–¥–ª—è —Å–∏—Å—Ç–µ–º–∫–∏)
LANG_NAMES = {
    "ru": "Russian",
    "en": "English",
    "fr": "French",
    "es": "Spanish",
    "de": "German",
    "sv": "Swedish",
    "fi": "Finnish",
}

def flag(code: str) -> str:
    return FLAGS.get((code or "en").lower(), "üè≥Ô∏è")

def short(code: str) -> str:
    return SHORT.get((code or "en").lower(), (code or "EN").upper())

def target_lang_title(code: str) -> str:
    return LANG_TITLES.get((code or "en").lower(), (code or "EN").upper())

# ‚Äî‚Äî‚Äî –û–Ω–±–æ—Ä–¥–∏–Ω–≥ (–æ–±–Ω–æ–≤–ª—ë–Ω–Ω—ã–π, –ª—ë–≥–∫–∏–π –∏ –±–ª–æ–∫–∞–º–∏)
ONBOARDING = {
    "ru": [
        "üß© –†–µ–∂–∏–º –ø–µ—Ä–µ–≤–æ–¥—á–∏–∫–∞ –≤–∫–ª—é—á—ë–Ω.",
        "–í–æ—Å–ø–æ–ª—å–∑—É–π—Å—è –∫–Ω–æ–ø–∫–∞–º–∏ –Ω–∏–∂–µ, —á—Ç–æ–±—ã –Ω–∞—Å—Ç—Ä–æ–∏—Ç—å –ø–µ—Ä–µ–≤–æ–¥—á–∏–∫:",
        "1) –ù–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ ‚Äî –∏–∑ —è–∑—ã–∫–∞ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞ –≤ —Ü–µ–ª–µ–≤–æ–π –∏–ª–∏ –Ω–∞–æ–±–æ—Ä–æ—Ç.",
        "2) –§–æ—Ä–º–∞—Ç ‚Äî –≥–æ–ª–æ—Å –∏–ª–∏ —Ç–µ–∫—Å—Ç.",
        "3) –°—Ç–∏–ª—å ‚Äî —Ä–∞–∑–≥–æ–≤–æ—Ä–Ω—ã–π –∏–ª–∏ –¥–µ–ª–æ–≤–æ–π.",
        "",
        "–ú–µ—Ç—Ç –ø–µ—Ä–µ–≤–æ–¥–∏—Ç –≤—Å—ë, —á—Ç–æ —Ç—ã –æ—Ç–ø—Ä–∞–≤–∏—à—å ‚Äî –±–µ–∑ –ª–∏—à–Ω–∏—Ö –æ–±—Å—É–∂–¥–µ–Ω–∏–π –∏ –≤–æ–ø—Ä–æ—Å–æ–≤. –ì–æ—Ç–æ–≤—ã–π —Ç–µ–∫—Å—Ç –º–æ–∂–Ω–æ –∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å, –∞ –∞—É–¥–∏–æ ‚Äî —Å—Ä–∞–∑—É –æ–∑–≤—É—á–µ–Ω–æ.",
        "–í–µ—Ä–Ω—É—Ç—å—Å—è –≤ –æ–±—ã—á–Ω—ã–π —Ä–µ–∂–∏–º: /translator_off",
    ],
    "en": [
        "üß© Translator mode is ON.",
        "Use the buttons below to tune the translator:",
        "1) Direction ‚Äî from interface language to target or the other way around.",
        "2) Output ‚Äî voice or text.",
        "3) Style ‚Äî casual or business.",
        "",
        "Matt will translate everything you send ‚Äî no extra chatter. Copy the text or use the ready voice.",
        "Back to chat mode: /translator_off",
    ],
}

def dir_compact_label(ui_code: str, direction: Direction, tgt_code: str) -> str:
    ui_flag, ui_short = flag(ui_code), short(ui_code)
    tg_flag, tg_short = flag(tgt_code), short(tgt_code)
    if direction == "ui‚Üítarget":
        return f"{ui_flag} {ui_short} ‚Üí {tg_flag} {tg_short}"
    return f"{tg_flag} {tg_short} ‚Üí {ui_flag} {ui_short}"

def output_label(ui: str, output: Output) -> str:
    if ui == "ru":
        return "üéô –ì–æ–ª–æ—Å" if output == "voice" else "‚úçÔ∏è –¢–µ–∫—Å—Ç"
    return "üéô Voice" if output == "voice" else "‚úçÔ∏è Text"

def style_label(ui: str, style: TStyle) -> str:
    if ui == "ru":
        return "üòé –†–∞–∑–≥–æ–≤–æ—Ä–Ω—ã–π" if style == "casual" else "ü§ì –î–µ–ª–æ–≤–æ–π"
    return "üòé Casual" if style == "casual" else "ü§ì Business"

def translator_status_text(ui: str, tgt_title: str, cfg: Dict[str, Any]) -> str:
    parts = ONBOARDING["ru"] if ui == "ru" else ONBOARDING["en"]
    return "\n".join(parts)

def get_translator_keyboard(ui: str, cfg: Dict[str, Any], tgt_code: str) -> InlineKeyboardMarkup:
    btn_dir = InlineKeyboardButton(
        dir_compact_label(ui_code=ui, direction=cfg["direction"], tgt_code=tgt_code),
        callback_data="TR:TOGGLE:DIR"
    )
    btn_out = InlineKeyboardButton(
        output_label(ui, cfg["output"]),
        callback_data="TR:TOGGLE:OUT"
    )
    btn_style = InlineKeyboardButton(
        style_label(ui, cfg["style"]),
        callback_data="TR:TOGGLE:STYLE"
    )
    btn_exit = InlineKeyboardButton(
        "–í—ã–π—Ç–∏" if ui == "ru" else "Exit",
        callback_data="TR:EXIT"
    )
    return InlineKeyboardMarkup([
        [btn_dir],
        [btn_out, btn_style],
        [btn_exit],
    ])

# === –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω–æ–µ: ¬´—Å–∂–∞—Ç–∏–µ¬ª –ø–æ —É—Ä–æ–≤–Ω—é ===
def _cap_for_level(level: str) -> str:
    lvl = (level or "A2").upper()
    if lvl == "A0": return "Keep it very simple. Max 1‚Äì2 short sentences."
    if lvl == "A1": return "Simple one-clause sentences. Max 1‚Äì3 sentences."
    if lvl == "A2": return "Clear basic grammar. Max 2‚Äì4 sentences."
    if lvl == "B1": return "Max 2‚Äì4 sentences."
    return "Max 2‚Äì5 sentences."  # B2‚ÄìC2

def _lang_name(code: str) -> str:
    c = (code or "en").lower()
    return LANG_NAMES.get(c, c.upper())

def _translator_system(
    *,
    direction: Direction,
    style: TStyle,
    level: str,
    interface_lang: str,
    target_lang: str,
    voice: bool,
) -> str:
    """
    –ö—Ä–∏—Ç–∏—á–Ω–æ: —Ñ–∏–∫—Å–∏—Ä—É–µ–º –∏—Å—Ö–æ–¥–Ω—ã–π –∏ —Ü–µ–ª–µ–≤–æ–π —è–∑—ã–∫–∏ —è–≤–Ω—ã–º —Ç–µ–∫—Å—Ç–æ–º,
    —á—Ç–æ–±—ã –º–æ–¥–µ–ª—å –ù–ï ¬´—Å–∫–∞—Ç—ã–≤–∞–ª–∞—Å—å¬ª –≤ –∞–Ω–≥–ª–∏–π—Å–∫–∏–π –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é.
    """
    d = "UI‚ÜíTARGET" if (direction or "ui‚Üítarget") == "ui‚Üítarget" else "TARGET‚ÜíUI"
    reg = "casual, idiomatic" if (style or "casual") == "casual" else "business, neutral, concise"
    caps = _cap_for_level(level)
    voice_hint = " Keep sentences short and well-paced for voice." if voice else ""

    # –ò—Å—Ç–æ—á–Ω–∏–∫/–Ω–∞–∑–Ω–∞—á–µ–Ω–∏–µ
    src_code = interface_lang if d == "UI‚ÜíTARGET" else target_lang
    dst_code = target_lang if d == "UI‚ÜíTARGET" else interface_lang
    src_name = _lang_name(src_code)
    dst_name = _lang_name(dst_code)

    # –ñ—ë—Å—Ç–∫–∏–µ —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è –∫ –≤—ã—Ö–æ–¥–Ω–æ–º—É —è–∑—ã–∫—É
    dst_guard = (
        f"Output MUST be in {dst_name} only. "
        f"Do NOT use English unless {dst_name} is English."
    )

    return (
        "You are a precise bilingual translator.\n"
        f"Direction: {d}. Register: {reg}. {caps}{voice_hint}\n"
        f"Source language: {src_name} (code: {src_code.upper()}).\n"
        f"Target language: {dst_name} (code: {dst_code.upper()}).\n"
        f"{dst_guard}\n"
        "Return ONLY the translation ‚Äî no comments, no templates, no follow-up question.\n"
        "No quotes/brackets. No emojis.\n"
        "Prefer established equivalents for idioms/proverbs; otherwise translate faithfully."
    )

# ====== –°—Ç—Ä–æ–≥–∏–π –¥–µ—Ç–µ—Ä–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –ø–µ—Ä–µ–≤–æ–¥ (—ç–∫—Å–ø–æ—Ä—Ç –¥–ª—è chat_handler) ======
async def do_translate(
    text: str,
    *,
    interface_lang: str,
    target_lang: str,
    direction: Direction,
    style: TStyle,
    level: str = "A2",
    output: Output = "text",       # "text" | "voice"
    timeout: float = 15.0,
) -> str:
    """
    –°—Ç—Ä–æ–≥–∏–π –∏ –±—ã—Å—Ç—Ä—ã–π –ø–µ—Ä–µ–≤–æ–¥: —É—á–∏—Ç—ã–≤–∞–µ—Ç –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ, —Å—Ç–∏–ª—å, —É—Ä–æ–≤–µ–Ω—å, —Ñ–æ—Ä–º–∞—Ç (voice/text).
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –¢–û–õ–¨–ö–û –ø–µ—Ä–µ–≤–æ–¥ ‚Äî –±–µ–∑ –∫–∞–≤—ã—á–µ–∫, —Å–∫–æ–±–æ–∫, —ç–º–æ–¥–∑–∏ –∏ –ø–æ—è—Å–Ω–µ–Ω–∏–π.
    """
    if not text:
        return ""

    ui  = (interface_lang or "en").lower()
    tgt = (target_lang or "en").lower()

    import re

    # 1Ô∏è‚É£ –ï—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –¥–∞–ª –≤–≤–æ–¥–∫—É –≤—Ä–æ–¥–µ "–ø–µ—Ä–µ–≤–µ–¥–∏ ..." –∏–ª–∏ "translate ..."
    #    ‚Äî –±–µ—Ä—ë–º —Ç–æ–ª—å–∫–æ —Ç–µ–∫—Å—Ç –ø–æ—Å–ª–µ —ç—Ç–∏—Ö —Å–ª–æ–≤
    pattern = r"(?:(?:translate|–ø–µ—Ä–µ–≤–µ–¥–∏|–∫–∞–∫ –±—É–¥–µ—Ç|—á—Ç–æ –∑–Ω–∞—á–∏—Ç|meaning of)\s*[:,\-‚Äì]?\s*)[\"‚Äú‚Äù']?(.*?)[\"‚Äú‚Äù']?$"
    m = re.search(pattern, text.strip(), re.IGNORECASE)
    if m and len(m.group(1)) > 1:
        text = m.group(1).strip()

    # 2Ô∏è‚É£ –ï—Å–ª–∏ —Å–æ–æ–±—â–µ–Ω–∏–µ –ø–æ—Ö–æ–∂–µ –Ω–∞ –≤–æ–ø—Ä–æ—Å (–Ω–∞—á–∏–Ω–∞–µ—Ç—Å—è —Å what/how/is/do –∏ —Ç.–ø.),
    #    —è–≤–Ω–æ —É—Ç–æ—á–Ω—è–µ–º GPT, —á—Ç–æ —ç—Ç–æ –∏–º–µ–Ω–Ω–æ —Ç–µ–∫—Å—Ç –¥–ª—è –ø–µ—Ä–µ–≤–æ–¥–∞, –∞ –Ω–µ –æ–±—Ä–∞—â–µ–Ω–∏–µ
    if re.match(r"^(what|how|can|is|are|do|does|did|where|who|when|why)\b", text.lower()):
        text = f"Translate this question only, do not answer it: {text}"

    sys = _translator_system(
        direction=direction,
        style=style,
        level=level,
        interface_lang=ui,
        target_lang=tgt,
        voice=(output == "voice"),
    )

    messages = [
        {"role": "system", "content": sys},
        {"role": "user", "content": text},
    ]

    logger.debug(
        "[TR] call: dir=%s style=%s lvl=%s out=%s ui=%s tgt=%s text_len=%d",
        direction, style, level, output, ui, tgt, len(text or "")
    )

    async def _call():
        # –º–∏–Ω–∏-–º–æ–¥–µ–ª—å: –±—ã—Å—Ç—Ä–µ–µ –∏ –¥–µ—à–µ–≤–ª–µ –¥–ª—è –ø–µ—Ä–µ–≤–æ–¥–æ–≤
        return await ask_gpt(messages, model="gpt-4o-mini", temperature=0.2, max_tokens=180)

    try:
        out = await asyncio.wait_for(_call(), timeout=timeout)
    except asyncio.TimeoutError:
        logger.error("[TR] do_translate timeout")
        # –º—è–≥–∫–∏–π —Ñ–æ–ª–±—ç–∫ ‚Äî –≤–µ—Ä–Ω—ë–º –∏—Å—Ö–æ–¥–Ω–∏–∫, —á—Ç–æ–±—ã –Ω–µ ¬´–º–æ–ª—á–∞—Ç—å¬ª
        return text.strip()
    except TypeError as e:
        # –µ—Å–ª–∏ –æ–±—ë—Ä—Ç–∫–∞ ask_gpt –ø–æ–∫–∞ –±–µ–∑ –∏–º–µ–Ω–æ–≤–∞–Ω–Ω—ã—Ö –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤
        logger.error("[TR] do_translate error (TypeError): %s", e)
        out = await ask_gpt(messages, model="gpt-4o-mini")

    result = (out or "").strip().strip("¬´¬ª\"'()[] \n\r\t")
    return result
